name: Build and Deploy Frontend to AWS EC2

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_NAME: reactjs-app

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    # Create Dockerfile dynamically
    - name: Create Dockerfile
      run: |
        cat > Dockerfile << 'EOF'
        # Build stage
        FROM node:20-alpine AS builder
        
        WORKDIR /app
        
        # Copy package files
        COPY package*.json ./
        
        # Install dependencies
        RUN npm ci
        
        # Copy all files
        COPY . .
        
        # Set build-time environment variable for API URL (relative path for Nginx proxy)
        ARG VITE_API_URL=/api
        ARG REACT_APP_API_URL=/api
        ENV VITE_API_URL=$VITE_API_URL
        ENV REACT_APP_API_URL=$REACT_APP_API_URL
        
        # Build the app
        RUN npm run build
        
        # Production stage
        FROM node:20-alpine
        
        WORKDIR /app
        
        # Install serve to run the build
        RUN npm install -g serve
        
        # Copy build from builder stage
        COPY --from=builder /app/dist ./dist
        
        # Expose port
        EXPOSE 3000
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
          CMD wget --no-verbose --tries=1 --spider http://localhost:3000 || exit 1
        
        # Start the app
        CMD ["serve", "-s", "dist", "-l", "3000"]
        EOF
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build Docker image
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest \
                     -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
                     --build-arg VITE_API_URL=/api \
                     --build-arg REACT_APP_API_URL=/api \
                     --build-arg BUILDKIT_INLINE_CACHE=1 .
    
    - name: Test Docker image
      run: |
        docker run --rm -d --name reactjs-service \
          -p 3000:3000 \
          ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        
        sleep 10
        
        # Check if container is running
        docker ps | grep reactjs-service || exit 1
        
        # Test if app responds
        curl -f http://localhost:3000 || exit 1
        
        # Stop test container
        docker stop reactjs-service
    
    - name: Push Docker image to Docker Hub
      run: |
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
    
    - name: Image digest
      run: echo "โ Frontend image pushed successfully!"

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
    
    steps:
    - name: Deploy to AWS EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "๐ Starting frontend deployment on AWS EC2..."
          
          # Login to Docker Hub
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          # Pull the latest image
          echo "๐ฆ Pulling latest Docker image..."
          docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # Stop and remove old container if exists
          echo "๐ Stopping old frontend container..."
          docker stop reactjs-app 2>/dev/null || true
          docker rm reactjs-app 2>/dev/null || true
          
          # Create Docker network if it doesn't exist
          echo "๐ Setting up Docker network..."
          docker network create my-app-network 2>/dev/null || echo "Network already exists"
          
          # Run new frontend container (NO PORT MAPPING - internal only)
          echo "โถ๏ธ  Starting new frontend container..."
          docker run -d \
            --name reactjs-app \
            --network my-app-network \
            --restart unless-stopped \
            -e VITE_API_URL=/api \
            -e REACT_APP_API_URL=/api \
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # Wait for container to start
          sleep 5
          
          # Check if container is running
          if docker ps | grep -q reactjs-app; then
            echo "โ Frontend container is running successfully!"
            docker ps | grep reactjs-app
          else
            echo "โ Frontend container failed to start!"
            echo "Container logs:"
            docker logs reactjs-app
            exit 1
          fi
          
          # Setup Nginx Reverse Proxy
          echo "๐ Setting up Nginx reverse proxy..."
          
          # Stop old nginx container
          docker stop nginx-proxy 2>/dev/null || true
          docker rm nginx-proxy 2>/dev/null || true
          
          # Remove any process using port 80
          echo "๐ Checking for processes on port 80..."
          PID=$(ss -tlnp 2>/dev/null | grep ":80 " | awk '{print $6}' | sed 's/.*pid=//;s/,.*//' | head -1)
          if [ ! -z "$PID" ]; then
            echo "โ๏ธ  Found process $PID using port 80, killing it..."
            sudo kill -9 $PID 2>/dev/null || true
            sleep 2
          fi
          
          # Create nginx configuration
          cat > /tmp/nginx.conf << 'NGINXEOF'
          events {
              worker_connections 1024;
          }
          
          http {
              # Enable gzip compression
              gzip on;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
              
              upstream frontend {
                  server reactjs-app:3000;
              }
              
              upstream backend {
                  server backend-app:5000;
              }
              
              server {
                  listen 80;
                  server_name _;
                  
                  # Security headers
                  add_header X-Frame-Options "SAMEORIGIN" always;
                  add_header X-Content-Type-Options "nosniff" always;
                  add_header X-XSS-Protection "1; mode=block" always;
                  
                  # Frontend requests (React app)
                  location / {
                      proxy_pass http://frontend;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection 'upgrade';
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Timeout settings
                      proxy_connect_timeout 60s;
                      proxy_send_timeout 60s;
                      proxy_read_timeout 60s;
                  }
                  
                  # Backend API requests
                  location /api/ {
                      proxy_pass http://backend/;
                      proxy_http_version 1.1;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      
                      # CORS headers (if needed)
                      add_header Access-Control-Allow-Origin * always;
                      add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                      add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
                      
                      # Handle preflight requests
                      if ($request_method = OPTIONS) {
                          return 204;
                      }
                      
                      # Timeout settings
                      proxy_connect_timeout 60s;
                      proxy_send_timeout 60s;
                      proxy_read_timeout 60s;
                  }
                  
                  # Health check endpoint
                  location /health {
                      access_log off;
                      return 200 "healthy\n";
                      add_header Content-Type text/plain;
                  }
              }
          }
          NGINXEOF
          
          # Start Nginx container
          echo "๐ Starting Nginx reverse proxy..."
          docker run -d \
            --name nginx-proxy \
            --network my-app-network \
            -p 80:80 \
            -v /tmp/nginx.conf:/etc/nginx/nginx.conf:ro \
            --restart unless-stopped \
            nginx:alpine
          
          # Wait for Nginx to start
          sleep 5
          
          # Check if Nginx is running
          if docker ps | grep -q nginx-proxy; then
            echo "โ Nginx proxy is running successfully!"
            docker ps | grep nginx-proxy
          else
            echo "โ Nginx proxy failed to start!"
            docker logs nginx-proxy
            exit 1
          fi
          
          # Clean up old Docker images (keep last 3)
          echo "๐งน Cleaning up old images..."
          docker images | grep "${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}" | tail -n +4 | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
          
          # Show all running containers
          echo "๐ Current running containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "๐ Frontend deployment completed successfully!"
    
    - name: Verify Deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "๐ Verifying frontend deployment..."
          
          # Check frontend container logs
          echo "๐ Frontend container logs (last 20 lines):"
          docker logs --tail 20 reactjs-app
          
          # Check Nginx logs
          echo "๐ Nginx proxy logs (last 20 lines):"
          docker logs --tail 20 nginx-proxy
          
          # Check container health
          echo "๐ฅ Container health status:"
          echo "Frontend: $(docker inspect reactjs-app --format='{{.State.Status}}')"
          echo "Nginx: $(docker inspect nginx-proxy --format='{{.State.Status}}')"
          echo "Backend: $(docker inspect backend-app --format='{{.State.Status}}' 2>/dev/null || echo 'Not running')"
          
          # Test if Nginx is responding on port 80
          echo "๐ Testing Nginx on port 80..."
          if curl -f http://localhost:80 >/dev/null 2>&1; then
            echo "โ Nginx is responding successfully!"
          else
            echo "โ Nginx is not responding!"
            exit 1
          fi
          
          # Test frontend through Nginx
          echo "๐ Testing frontend through Nginx..."
          if curl -f http://localhost/ >/dev/null 2>&1; then
            echo "โ Frontend is accessible through Nginx!"
          else
            echo "โ๏ธ  Warning: Frontend not responding through Nginx"
          fi
          
          # Test backend API through Nginx
          echo "๐ Testing backend API through Nginx..."
          if curl -f http://localhost/api/users >/dev/null 2>&1; then
            echo "โ Backend API is accessible through Nginx!"
          else
            echo "โ๏ธ  Warning: Backend API not responding (make sure backend is deployed)"
          fi
          
          # Test internal Docker network connectivity
          echo "๐ Testing Docker network connectivity..."
          if docker exec reactjs-app wget -qO- http://backend-app:5000/api/users >/dev/null 2>&1; then
            echo "โ Frontend can reach backend via Docker network!"
          else
            echo "โ๏ธ  Warning: Cannot reach backend from frontend container"
          fi
          
          # Show network information
          echo "๐ Docker network information:"
          docker network inspect my-app-network --format='{{range .Containers}}{{.Name}}: {{.IPv4Address}}{{"\n"}}{{end}}'
          
          echo "โ Verification complete!"
    
    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo "๐ โ DEPLOYMENT SUCCESSFUL!"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo ""
          echo "๐ Your application is now live at:"
          echo "   ๐ http://${{ secrets.EC2_HOST }}"
          echo ""
          echo "๐ก API endpoint:"
          echo "   ๐ http://${{ secrets.EC2_HOST }}/api"
          echo ""
          echo "๐ง Architecture:"
          echo "   โข Nginx Proxy (Port 80) โ Handles all incoming traffic"
          echo "   โข Frontend (reactjs-app:3000) โ Internal Docker network"
          echo "   โข Backend (backend-app:5000) โ Internal Docker network"
          echo ""
          echo "โจ All services are communicating via Docker network!"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
        else
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo "โ DEPLOYMENT FAILED!"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo ""
          echo "Please check the logs above for error details."
          echo "Common issues:"
          echo "  โข Docker login failed"
          echo "  โข Port 80 already in use"
          echo "  โข Backend container not running"
          echo "  โข Network connectivity issues"
          echo ""
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
        fi